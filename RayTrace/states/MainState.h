#pragma once

#include "State.h"
#include <SDL_ttf.h>

#include "../Ray.h"
#include <clew.h>
#include "../Texture.h"
#include "../Cube.h"
#include "../misc/PerformanceCounter.h"

class StateManager;

/** @brief	The main state. */
class MainState : public State
{
public:

	/**
	 @brief	Constructor.
	
	 @param [in,out]	manager 	If non-null, the manager.
	 @param [in,out]	platform	If non-null, the platform.
	 */
	MainState(StateManager* manager, Platform* platform);

	/** @brief	Destructor. */
	virtual ~MainState();

	/**
	@brief Handles any events such as keyboard/mouse input
	@return Continue the game
	*/
	virtual bool eventHandler();

	/**
	@brief Update any internal values
	*/
	virtual void update();

	/**
	@brief Render any sprites relevant to the state
	*/
	virtual void render();
protected:

	/** @brief	Modes of the ray tracer. */
	enum Mode
	{
		CPU,
		OpenCL
	};

	//UI
	/** @brief	The font. */
	TTF_Font* font;
	/** @brief	The text colour. */
	SDL_Colour textColour;

	/** @brief	The mode UI element. */
	Texture* mode;
	/** @brief	The mode switch UI element. */
	Texture* modeSwitch;
	/** @brief	The time taken user interface. */
	Texture* timeTakenUI;
	/** @brief	The scene number user interface. */
	Texture* sceneNumberUI;
	/** @brief	The scene switch UI element. */
	Texture* sceneSwitch;
	/** @brief	The please wait UI element. */
	Texture* pleaseWait;

	/** @brief	The performance counter that measures the performance of the ray tracer. */
	PerformanceCounter timer;
	/** @brief	The previous value from the performance counter. */
	uint64_t timeTaken;

	/** @brief	The array of pixels. */
	std::vector<int> pixels;
	/** @brief	Number of pixels. */
	int pixelCount;

	/** @brief	The image generated by the ray tracer. */
	Texture* image;

	/** @brief	Number of triangles per cube. */
	const int numOfTrianglesPerCube = 12;
	/** @brief	Number of points in a triangle. */
	const int numOfPointsInTriangle = 3;

	//Rays
	/** @brief	The ray direction. */
	glm::vec4 rayDir;
	/** @brief	The array of ray origins. */
	std::vector<glm::vec4> rayOrigins;

	//Scene Objects
	/** @brief	The array of sphere origins. */
	std::vector<glm::vec4> sphereOrigins;
	/** @brief	The array of sphere radius. */
	std::vector<float> sphereRadius;
	/** @brief	List of colours of the spheres. */
	std::vector<glm::vec4> sphereColours;

	/** @brief	The array of cubes. */
	std::vector<Cube> cubes;

	//Ray Tracer Status flags
	/** @brief	True if ray tracing in progress. */
	bool rayTracingInProgress;
	/** @brief	Set to true to start the ray tracer. */
	bool start;
	/** @brief	The current scene number. */
	int currentScene;
	/** @brief	True to trigger a scene change. */
	bool sceneChange;
	/** @brief	The current mode. */
	Mode currentMode;

	//SceneCreation
	/** @brief	Creates scene 1. */
	void createScene1();
	/** @brief	Creates scene 2. */
	void createScene2();
	/** @brief	Creates scene 3. */
	void createScene3();

	//OpenCL
	/** @brief	The OpenCL program. */
	cl_program program;
	/** @brief	The OpenCL context. */
	cl_context context;
	/** @brief	The OpenCL command queue. */
	cl_command_queue cmdQueue;
	/** @brief	The OpenCL kernel. */
	cl_kernel kernel;

	/** @brief	Executes the ray tracer using OpenCL. */
	void executeRayTracerOpenCL();

	/** @brief	Executes the ray tracer using CPU. */
	void executeRayTracerCPU();

	/** @brief	Generates an image from pixel data provided by the ray tracer. */
	void generateImageFromPixels();


	//OpenCL Utility Functions
	/**
	 @brief	Loads compute shader from file.
	
	 @param	path	Full pathname of the file.
	
	 @return	The compute shader file contents.
	 */
	std::string loadComputeShaderFromFile(std::string path);

	/**
	 @brief	cl_device_type to string.
	
	 @param	type	The type.
	
	 @return	A std::string of the type.
	 */
	std::string clDeviceTypeToString(cl_device_type type);

	/**
	 @brief	Gets OpenCL error string.
	
	 @param	error	The error.
	
	 @return	Null if it fails, else the error string.
	 */
	const char *getErrorString(cl_int error);

	/** @brief	OpenCL initialization. */
	void openCLInit();

	//Debug Rendering to a PNG image
	/**
	 @brief	Encode PNG.
	
	 @param 			filename 	Filename of the file.
	 @param [in,out]	imageData	Information describing the image.
	 @param 			width	 	The width.
	 @param 			height   	The height.
	 */
	void encodePNG(const char* filename, std::vector<unsigned char>& imageData, unsigned width, unsigned height);

	//Ray Tracer CPU Functions
	/**
	 @brief	Intersect triangle.
	
	 @param 			orig 	The ray origin.
	 @param 			dir  	The ray direction.
	 @param 			vert0	Triangle Point 1.
	 @param 			vert1	Triangle Point 2.
	 @param 			vert2	Triangle Point 3.
	 @param [in,out]	t	 	If non-null, the double to process.
	 @param [in,out]	u	 	If non-null, the double to process.
	 @param [in,out]	v	 	If non-null, the double to process.
	
	 @return	1 if intersecting or 0 if not.
	 */
	int intersectTri(double orig[3], double dir[3], double vert0[3], double vert1[3], double vert2[3], double *t, double *u, double *v);

	/**
	 @brief	Intersect sphere.
	
	 @param [in,out]	inRayOrigin   	The ray origin.
	 @param [in,out]	inRayDirection	The ray direction.
	 @param 			inSphereRadius	The sphere radius.
	 @param [in,out]	inSphereOrigin	The sphere origin.
	
	 @return	A float containing the distance.
	 */
	float intersectSphere(glm::vec4& inRayOrigin, glm::vec4& inRayDirection, float inSphereRadius, glm::vec4& inSphereOrigin);

	/**
	 @brief	Checks the passed in ray collides with any of the shapes passed in.
	
	 @param [in,out]	ray			   	The ray.
	 @param 			inCubes		   	The cubes.
	 @param 			inSphereRadius 	The sphere radius.
	 @param 			inSphereOrigins	The sphere origins.
	 @param 			inSphereColours	List of colours of the spheres.
	
	 @return	The Colour value for this pixel/ray. Black if no intersect.
	 */
	glm::vec4 collide(Ray& ray, std::vector<Cube> inCubes, 
		std::vector<float> inSphereRadius, std::vector<glm::vec4> inSphereOrigins, std::vector<glm::vec4> inSphereColours);
};